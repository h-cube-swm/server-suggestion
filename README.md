# 유사 설문 추천 서버

본 프로젝트에서는 Python을 기반으로 설문 문항을 입력받아 유사한 설문 문항을 추천해주는 서버를 구현하였다.

## 사용 기술

- FastAPI
- Hanspell
- KoNLP
- Scikit Learn
- Numpy

## 작동 원리

1. 먼저 `surveys.txt` 파일에 행으로 구분되는 많은 설문 질문들을 준비한다.
1. `preprocess.py` 스크립트를 실행한다. 이 스크립트는 `surveys.txt` 파일의 각 행에 대하여 다음과 같이 동작한다.

   1. 각 행을 `hanspell` 라이브러리를 사용하여 교정한다.
   1. 교정한 텍스트를 `koNLP`라이브러리의 `Kkma(꼬꼬마)` tokenizer를 사용하여 토큰화한다. 그 결과 형태소별로 나눠진 토큰들을 얻는다.
   1. 이 토큰들을 띄어쓰기를 사용하여 concatenate한다.
   1. 이렇게 concatenate한 텍스트와 교정한 텍스트를 `<SPLIT>` 이라는 splitter를 사용하여 연결한다.

   그런 후 이렇게 변환한 텍스트를 `parsed.txt`에 출력한다.

   각 행에 이루어지는 작업의 예를 들면 다음과 같다.

   - 원문 : `당신은 몇살이십니까?`
   - 결과 : `당신은 몇 살이십니까?<SPLIT>당신 은 몇 살 이 시 ㅂ니까 ?`

   이렇게 하는 이유는 한국어가 교착어, 즉 어근과 접사가 붙어서 하나의 단어를 이루는 형태를 가지기 때문이다. 만약 이렇게 tokenizer를 사용하지 않고 단순히 공백 기반으로만 단어를 분리할 경우 `이름을` 과 `이름은` 이 서로 다른 단어로 인식된다. 그러나 tokenizer를 사용할 경우 `이름 은`과 `이름 을`로 단어가 쪼개지므로 서로 같은 단어가 포함됨을 알 수 있다.

   또한 `koNLP` 라이브러리에서는 명사 추출 기능을 제공하지만 그 기능을 사용하지 않은 이유는 설문조사에서는 동사도 중요하기 때문이다. 예를 들어 `이 영화를 좋아하십니까?`와 `이 영화를 싫어하십니까?`와 같은 경우가 그렇다.

   그리고 이렇게 알고리즘을 구성하면 `좋아하다`와 `선호하다`가 서로 다른 단어로 인식된다. Word2Vec 등의 기술을 사용하면 이런 단점을 해결할 수 있다. 그러나 그렇게 하지 않은 이유는 `Word2Vec`을 사용하려면 시간이 오래 걸릴 수 있고 또 유사도 기반 탐색에서 괜찮은 성능을 보이는 TF-IDF 알고리즘을 사용할 수 없기 때문이다.

1. 이후에 `tester.py` 라이브러리의 `get_order` 함수를 사용하면 미리 등록된 설문들을 유사도 순으로 가져올 수 있다. `tester.py`는 로드될 때 `parsed.txt`를 읽어서 tokenize된 부분을 이용하여 TF-IDF vectorizer를 생성해둔다. 이후 `get_order`함수에서는 미리 생성된 vectorizer를 사용하여 파라매터로 받은 설문을 vectorize하고, 이 vector와 미리 등록된 설문들의 vector들의 distance를 기반으로 미리 등록된 설문을 정렬, 스코어와 함께 반환한다.
